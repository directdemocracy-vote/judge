<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>test.directdemocracy.vote</title>
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" sizes="any">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/framework7-icons@5.0.5/css/framework7-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
  </head>
  <body>
    <canvas id="worldMap" width="512" height="512" style="border:1px solid #000000;"></canvas>
    <div id="idPlaceholder" style="width: 512px; height: 512px; position: absolute; top: 0px; left: 600px"></div>
    <div id="menu">
      <button id="reputation">Compute reputation</button>
      <button id="age">Next year</button>
    </div>
  </body>
  <script type="module">
    import World from './js/World.js';
    import Arrow from './js/Arrow.js';
    import Citizen from './js/Citizen.js';

    const c = document.getElementById('worldMap');
    const ctx = c.getContext("2d");

    World.init(ctx, c);

    const idPlaceholder = document.getElementById('idPlaceholder');
    const reputationButton = document.getElementById('reputation');
    reputationButton.onclick = () => {
      World.instance.computeReputation();
      draw()
    }
    const ageButton = document.getElementById('age');
    ageButton.onclick = () => World.instance.year++;

    let selection;

    const canvas = document.querySelector('canvas')
    canvas.addEventListener('mousedown', event => {
      if (event.buttons === 1)
        getCursorPosition(canvas, event);
      else if (event.buttons === 2)
        initializeTranslationOfViewpoint(event);

    });

    canvas.addEventListener("mousemove", event => translateViewpoint(event));

    // prevent context menu to pop
    canvas.oncontextmenu = () => {return false;}

    canvas.addEventListener('wheel', event => {
      if (event.deltaY < 0)
        World.instance.zoomLevel += 1;
      else
        World.instance.zoomLevel -=1;

      if (World.instance.zoomLevel <= 0)
        World.instance.zoomLevel = 1;
      else if (World.instance.zoomLevel > World.instance.maxZoomLevel)
        World.instance.zoomLevel = World.instance.maxZoomLevel;
      draw(true);


    });

    canvas.addEventListener("mouseup", () => World.instance.mouseDown = false);
    canvas.addEventListener("mouseover", () => World.instance.mouseDown = false);
    canvas.addEventListener("mouseout", () => World.instance.mouseDown = false);

    function draw() {
      clear();
      World.instance.ctx.save();
      World.instance.ctx.translate(World.instance.translatePosition.x, World.instance.translatePosition.y);

      for (const citizen of World.instance.citizens.values()) {
        const path = new Path2D();
        path.arc(citizen.coords[0] / Math.pow(2, World.instance.maxZoomLevel - World.instance.zoomLevel), citizen.coords[1] / Math.pow(2, World.instance.maxZoomLevel - World.instance.zoomLevel), citizen.size, 0, 2 * Math.PI);
        citizen.path = path;

        if (citizen.endorsed)
          World.instance.ctx.fillStyle = "green";
        else
          World.instance.ctx.fillStyle = "red";

        World.instance.ctx.fill(path);
      }

      for (const endorsement of World.instance.endorsements.values()) {
        World.instance.ctx.fillStyle = "black";
        endorsement.buildLine();
        if (endorsement.arrowHead1)
          endorsement.rebuildArrowHead(endorsement.arrowHead1);
        if (endorsement.arrowHead2)
          endorsement.rebuildArrowHead(endorsement.arrowHead2);
      }

      World.instance.ctx.restore();
    }

    function drawPoint(x, y) {
      const point = new Path2D();
      const coordX = (x - World.instance.translatePosition.x) * Math.pow(2, World.instance.maxZoomLevel - World.instance.zoomLevel);
      const coordY = (y - World.instance.translatePosition.y) * Math.pow(2, World.instance.maxZoomLevel - World.instance.zoomLevel);
      point.arc(x, y, World.instance.basePointSize, 0, 2 * Math.PI);

      const id = World.instance.idGenerator++
      const citizen = new Citizen(id, point, [coordX, coordY], World.instance.basePointSize);
      World.instance.citizens.set(id, citizen);
      draw();
    }

    function drawEndorsment(id1, id2) {
      for (const endorsement of World.instance.endorsements.values()) {
        if ((id1 === endorsement.idPoint1 || id1 === endorsement.idPoint2) && (id2 === endorsement.idPoint1 || id2 === endorsement.idPoint2)) {

          // The endorsement already exists
          if ((typeof endorsement.arrowHead1 !== 'undefined' && endorsement.arrowHead1.source === id1 && endorsement.arrowHead1.destination === id2) ||
              (typeof endorsement.arrowHead2 !== 'undefined' && endorsement.arrowHead2.source === id1 && endorsement.arrowHead2.destination === id2)) {
              resetSelection();
              return;
          }

          // Reverse endorsement already exists
          endorsement.buildArrow(id1, id2);
          resetSelection();
          return;
        }
      }

      const id = World.instance.idGenerator++;
      const arrow = new Arrow(id, id1, id2);
      World.instance.endorsements.set(id, arrow);
      resetSelection();
    }

    function clear() {
      World.instance.ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function getCursorPosition(canvas, event) {
      const rect = canvas.getBoundingClientRect()
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const xTranslated = x - World.instance.translatePosition.x;
      const yTranslated = y - World.instance.translatePosition.y;

      const id = isOnPoint(xTranslated, yTranslated);
      if (typeof id === 'undefined') {
        if (typeof selection !== 'undefined') {
          resetSelection()
        } else
          drawPoint(x, y);
      } else {
        if (World.instance.citizens.has(id)) {
          if (typeof selection === 'undefined') {
            changePointSize(id, World.instance.selectedPointSize)
            selection = id;

            const citizen = World.instance.citizens.get(id)
            idPlaceholder.innerHTML = "";
            const idDiv = document.createElement('div');
            idDiv.innerHTML = "ID: " + id;
            idPlaceholder.appendChild(idDiv);
            const distanceDiv = document.createElement('div');
            distanceDiv.innerHTML = "Reputation: " + citizen.reputation;
            idPlaceholder.appendChild(distanceDiv);
            revokeButton(id);
          } else {
            drawEndorsment(selection, id)
          }
        } else {
          let line;
          let head;
          for (const endorsement of World.instance.endorsements.values()) {
            if (endorsement.arrowHead1 && endorsement.arrowHead1.id === id) {
              line =  endorsement;
              head = 1
              break;
            } else if(endorsement.arrowHead2 && endorsement.arrowHead2.id === id) {
              line =  endorsement;
              head = 2
              break;
            }
          }

          idPlaceholder.innerHTML = "";
          const idDiv = document.createElement('div');
          idDiv.innerHTML = "ID: " + id;
          idPlaceholder.appendChild(idDiv);
          const distanceDiv = document.createElement('div');
          distanceDiv.innerHTML = "Distance: " + line.distance + "km";
          idPlaceholder.appendChild(distanceDiv);
          const ageDiv = document.createElement('div');
          const age = head === 1 ? line.arrowHead1.age : line.arrowHead2.age;
          ageDiv.innerHTML = "Year: " + age;
          idPlaceholder.appendChild(ageDiv);
          revokeButton(id);
        }
      }
    }

    function isOnPoint(x, y) {
      for (const entry of World.instance.citizens.entries()) {
        if (World.instance.ctx.isPointInPath(entry[1].path, x, y))
          return entry[0];
      }

      for (const entry of World.instance.endorsements.entries()) {
        if (typeof entry[1].arrowHead1 !== 'undefined' && World.instance.ctx.isPointInPath(entry[1].arrowHead1.path, x, y))
          return entry[1].arrowHead1.id;
        if (typeof entry[1].arrowHead2 !== 'undefined' && World.instance.ctx.isPointInPath(entry[1].arrowHead2.path, x, y))
          return entry[1].arrowHead2.id;
      }
    }

    function resetSelection() {
      changePointSize(selection, World.instance.basePointSize);
      selection = undefined;
      idPlaceholder.innerHTML = "";
    }

    function changePointSize(id, newSize) {
      if (typeof id === 'undefined')
        return;

      const citizen = World.instance.citizens.get(id);
      const coords = citizen.coords;
      const path = new Path2D();
      path.arc(coords[0] / Math.pow(2, World.instance.maxZoomLevel - World.instance.zoomLevel), coords[1] / Math.pow(2, World.instance.maxZoomLevel - World.instance.zoomLevel), newSize, 0, 2 * Math.PI);
      citizen.path = path;
      citizen.size = newSize;
      draw();
    }

    function initializeTranslationOfViewpoint(event) {
      World.instance.mouseDown = true;
      World.instance.startDragOffset.x = event.clientX - World.instance.translatePosition.x;
      World.instance.startDragOffset.y = event.clientY - World.instance.translatePosition.y;
    }

    function translateViewpoint(event) {
      if (World.instance.mouseDown) {
        World.instance.translatePosition.x = event.clientX - World.instance.startDragOffset.x;
        World.instance.translatePosition.y = event.clientY - World.instance.startDragOffset.y;
        draw();
      }
    }

    function revokeButton(id) {
      const button = document.createElement('button')
      button.innerHTML = "Revoke";
      button.onclick = () => {
        if (World.instance.citizens.has(id)) {
          World.instance.citizens.delete(id);
          for (const endorsement of World.instance.endorsements.values()) {
            if (endorsement.idPoint1 === id || endorsement.idPoint2 === id)
              World.instance.endorsements.delete(endorsement.id);
          }
        } else {
          for (const endorsement of World.instance.endorsements.values()) {
            if (typeof endorsement.arrowHead1 !== 'undefined' && endorsement.arrowHead1.id === id ||
              typeof endorsement.arrowHead2 !== 'undefined' && endorsement.arrowHead2.id === id)
              World.instance.endorsements.delete(endorsement.id);
          }
        }
        selection = undefined;
        draw();
      }
      idPlaceholder.appendChild(button);
    }
  </script>
</html>
